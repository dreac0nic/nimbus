#ifndef NIMBUS_PROFILER_H
#define NIMBUS_PROFILER_H

#include "Segment.h"

namespace Nimbus
{
    namespace Profiler
    {
        /** The Profiler class provides a relatively clean interface to the
            profiling functionality. Profiling allows program execution to be
            broken down into trackable segments of execution. The profiler
            keeps track of the time taken by the execution of each segment
            and also keeps track of whch segments are children of other segments.

            The Profiler is not a singleton, so any number of Profilers may be
            created, however, they do not feed back into each other and should be
            considered completely independent entities.

            Each Segment in the Profiler contains a two part identifier - the
            Module and the Status. The Module indicates the module of code the
            Profiler is monitoring during that segment. The Status indicates the
            status of the Module during the Segment's period of execution. For
            instance, given a text editor, a module might be the "I/O Module"
            and the status might be "Saving". These identifiers permit debuggers
            to track the time the program spends in a given Module or accomplishing
            a specific task in a Module.

            To use the Profiler, create a new Profiler object using the constructor.
            Then call the start function to start the overall timer of the Profiler.
            To add sub-Segments to the profiler, call the startSegment() function,
            giving it appropriate Module and Status values. Segments started before
            a previous one completes are automatically assumed to be child segments.
            To terminate tracking a Segment, call the endSegment() function, passing
            it the same (case-sensitive) Module and Status values that were used to
            create the Segment. Note that mismatching Module and Status values will
            not close the current Segment, so following Segments may be incorrectly
            added as children to the unclosed Segment.

            Profiler output may be seen as a string using the str() function or as a
            database, which may be constructed using SQL statements generated by the
            sqlOut() function.
         */
        class Profiler
        {
        private:
            // Private members

            /// For keeping track of segment ids
            int mSqlId;

            /// The root of the profiler segment tree
            Segment* mRootSegment;

            /// The profiler segment currently in progress
            Segment* mCurrentSegment;

            /** Recursively builds a string representing the profile segment tree.

                @param printNode The current node being explored in the building process.
                @return The string containing the information from all children segments.
             */
            std::string strTree(Segment* printNode);

            /** Recursively builds a string of sql queries, encoding the profile segment tree.

                @param printNode The current node being explored in the building process.
                @param parentId The parent id for the next level.
                @return The string containing the sql queries from all child segments.
             */
            std::string sqlTree(Segment* printNode, int parentId);

        public:
            /** Creates a profiler with a generic name.
             */
            Profiler();

            /** Creates a profiler with the given details.

                @param module The module of the profiler being created.
                @param status The status of the module the profiler tracks.
             */
            Profiler(std::string module, std::string status);

            /** Destroys the profiler.
             */
            ~Profiler();

            /** Starts the profiler.
                (NOTE: No child segments may be added until the profiler has been started)
             */
            void start();

            /** Ends the profiler.
                (NOTE: NO child segments may be added after the profiler has been ended)
             */
            void end();

            /** Starts a child segment for the current profiler segment.

                @param module The module of the new child segment.
                @param status The status of the child segment module.
             */
            void startSegment(std::string module, std::string status);

            /** Ends the given segment.
                If the details do not match the given segment, then no segment is ended.

                @param module The module of the new child segment.
                @param status The status of the child segment module.
             */
            void endSegment(std::string module, std::string status);

            /** Gets the root of the segment tree.
                Use of this tree requires knowledge of the internal workings of the profiler.

                @return The root segment object.
             */
            Segment* getRoot();

            /** Constructs a string summarizing the results of the profiler as it currently exists.

                @return A string containing the summary of the profiler results.
             */
            std::string str();

            /** Constructs a string containing SQL to construct a database containing profiling data.
                Populates a database named "profile" with a table named "segment_table". This table
                contains the following fields:

                id INT
                    This field is the numerical id of the execution Segment.

                module TEXT
                    This field contains the Module name of the execution Segment.

                status TEXT
                    This field contains the Status value of the execution Segment.

                duration INT
                    This field is the duration of the execution time for this Segment in millisecond units.

                parent_id INT
                    This field is the id of the parent Segment to this one. Note that the root node
                    contains a parent_id of 0 while its own id is 1.

                @return A string containing (hopefully ANSI) SQL queries that construct a database.
             */
            std::string sqlOut();
        };
    }
}

#endif // NIMBUS_PROFILER_H
